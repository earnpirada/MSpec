function binArray= generateBinsFromEdges(edgeList,MZvalues,intensities)
    % edgeList is generated by the function 'generateBins'
    % + Max M/z at the back
    
    dataArray = [MZvalues intensities]
    [MZNumber,SpecNumber] = size(intensities);

    binIndexList = (1:size(edgeList)+1);
    allBinIntensityList = [];
    
    % Data Validation is not done yet.
    
    for k = 1:SpecNumber    % for each spectra
        binIntensityList = [];  % currrent spec accumulate intensities
        currentAccumulate = 0;  % currrent m/z accumulate intensities
        edgeIndex = 1;
    
        for i = 1:MZNumber % for each m/z
            % if bad perf alternative way is to add the last MZ to the
            % edgelist first
            % if edgeIndex > size(edgeList) % stop increasing edgeindex
            %   currentAccumulate = currentAccumulate + dataArray(i,k+1);
                
                %=====
            if dataArray(i,1) <= edgeList(edgeIndex) % if current MZ is less than equal current edge
                currentAccumulate = currentAccumulate + dataArray(i,k+1);
                %sprintf("Acc: %d ---> Acc: %d", dataArray(i,k+1), currentAccumulate)
            else
                % save current bin
                %sprintf("spec %d break at edge: %d, m/z value: %d , Acc: %d", k, edgeIndex,dataArray(i,1), currentAccumulate)
                binIntensityList = [binIntensityList; currentAccumulate];
                edgeIndex = edgeIndex+1;
                currentAccumulate = dataArray(i,k+1);
            end
        end
        % finalize the last step
        binIntensityList = [binIntensityList; currentAccumulate];
        allBinIntensityList = [allBinIntensityList binIntensityList];
    end    
    binArray = [transpose(binIndexList) allBinIntensityList];
    %binArray = [binIndexList allBinIntensityList];
end